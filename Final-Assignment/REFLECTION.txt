  Over the course of CS 162, the most crucial thing I was able to learn from this class was the importance of a good design. With each subsequent program, the amount of code and files that were required to complete the assignment continued to grow and I realized that organization beforehand was extremely important. In high school during my programming class, I learned about the "top-down" approach where you start at the highest level of your code structure and work down to more implemented levels of your design. For example, in this final design, I began writing out my pseudocode for the main() function as it was what contained the highest level of logic with manipulating the maze object. Then I went into my maze class and implemented the pseudocode in such a way that my main() function used it. This continued all the way down to the most specific classes such as IntrepidStudent or Wall/OpenSpace, and it really helped keep my code concise and organized since it forced me to only make methods for each class that would for certain be used, rather than implementing methods that would possibly not get used by other classes.
  My test plan for my program was to continuously execute the program after each method for a class was created. Although I chose to design my code from the highest logic to the most lowest, I implemented my code the other way around. Starting with my IntrepidStudent class (and its parent class MazePerson), I implemented the getMove() function and tested if it correctly took in my input from the console and error handled it appropriately. This was done through creating an instance of IntrepidStudent and calling its respective methods. This was repeated for every additional class I created and this ensured that a bug early on will not snowball into a really huge bug later on when other classes begin to rely on each other's implementation.
  I found my testing process to be really efficient and it enabled me to finish this project really early on. But along the way I definitely ran into some rough bugs that were difficult to fix, with a particularly difficult one focusing on the interaction between different maze levels. A bug that took my a while to figure out how to fix was trying to carry over the amount of programming skills the player had as they climbed from level to level. The issue that I was initially having was that every time the IntrepridStudent would go up a floor, their programming skills would be reset back to 0. At first I was really worried since I thought I would have to completely reimplement the way I had structured my Maze and MazeLevels, but after giving it a lot of thought and consideration I decided to add an additional getter and setter method at the MazeLevel to obtain and set the IntrepridStudent's programming skill count at the current level and repeatedly set each of the mazelevels to have the same number for each turn that was taken. This way, with each turn, the amount of programming skills for each IntrepidStudent object on each MazeLevel will get updated with each turn. Past that, the rest of the program went really smoothly.
  After finishing the main logic for my program, I sought out Stack Overflow and other resources in order to attempt to make my program seem much more cleaner and smoother. From the Piazza hub for our class, I found that a student has recommended the use of system("clear") in order to clean out the console and I decided to include that in my code. This really helped make the movement of the TAs and the student to be much more clear rather than having a continuous stream of mazes be printed for each subsequent move. Another thing that I found annoying was the fact that you have to push the "enter" key after each move rather than just pushing the AWSD keys to move like you would in a standard game. I tried doing research on how to implement my code so it would do this and came across a library called conio.h with a function called getch(). Unfortunately, despite after an hour of trying to make it work, I discovered on another StackOverflow page that this feature doesn't seem to work on Linux terminals.
  I feel very confident about my program and I implemented it in such a way that any text file that is appropriately formatted could be inputted and used as a maze (as I have tested it with my own mazes). I believe that I was able to fulfill all of the requirements that were laid out in the README file and that there are no bugs or memory leaks when I was testing it. Something that may happen if you are unlucky is that when you climb the ladder, the TA on the next floor is standing next to the start and you lose all of your programming skills. Overall, my experience in this class was amazing. In high school I was only really able to briefly touch upon each of these topics such as polymorphism, inheritance, and abstract classes, but this was my first time actually created my own programs with these techniques. I really enjoyed my time in this class and the instructor along with the TA's were great teachers. Thank you for such a great term!!

 -Mark Huynh

 (This file was typed on the terminal, which autoindented my lines)
